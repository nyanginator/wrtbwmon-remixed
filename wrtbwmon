#!/bin/sh
#
# Traffic logging tool for DD-WRT based routers
#
# This version created by Nicholas Yang
#
# Based on original work wrtbwmon by Emmanuel Brucy (e.brucy AT qut.edu.au),
# which is based on work from:
#   - Fredrik Erlandsson (erlis AT linux.nu)
#   - traff_graph script by twist - http://wiki.openwrt.org/RrdTrafficWatch
#

DIR="$( cd "$( dirname "$0" )" && pwd )"
. $DIR/config

DATE=`date -u +"%s"`
DATEHOURADJ=0
DATE=$((DATE+(DATEHOURADJ*3600)))
DATESTAMPYEAR=$(date +\%Y -d @${DATE})
DATESTAMPMONTH=$(date +\%m -d @${DATE})
DATESTAMPDAY=$(date +\%d -d @${DATE})
DATESTAMPTIME=$(date +\%H\.\%M.\%S -d @${DATE})

# Strings to identify today's date and match against dates saved in the daily,
# weekly, monthly, and yearly DB files
DATEIDDAY=$(date +\%d-\%m-\%Y -d @${DATE})
DATEIDWEEK=$(date +\%V-\%Y -d @${DATE})
DATEIDMONTH=$(date +\%m-\%Y -d @${DATE})
DATEIDYEAR=$(date +\%Y -d @${DATE})

# getSize() in the JS expects an argument in bytes, so append this variable as
# a suffix to convert values from the .db files into bytes
UNITTOBYTES=""
if  [ "${UNIT}" == "MB" ]; then
   UNITTOBYTES=000000
elif  [ "${UNIT}" == "KB" ]; then
   UNITTOBYTES=000
fi

LAN_IFACE=$(nvram get lan_ifname)

lock()
{
    while [ -f /tmp/wrtbwmon.lock ]; do
        if [ ! -d /proc/$(cat /tmp/wrtbwmon.lock) ]; then
            echo "WARNING : Lockfile detected but process $(cat /tmp/wrtbwmon.lock) does not exist !"
            rm -f /tmp/wrtbwmon.lock
        fi
        sleep 1
    done
    echo $$ > /tmp/wrtbwmon.lock
}

unlock()
{
    rm -f /tmp/wrtbwmon.lock
}

# Creates the HTM page for a specific daily/weekly/yearly/monthly chart
publishgraphhtm()
{
  DBPATH=$1
  SUFFIX=$2
  HTMPATH=$3
  TITLE=$4
  AXISRANGE=$5
  MAC=$6

  if [ -f ${DBPATH} ]; then
    # Offset to account for February and leap years; we want the day in the
    # middle of the month, if we're calculating for year/month
    THEDAYTODAY=$(date +\%e -d @${DATE})
    OFFSET=$(((THEDAYTODAY - 15) * 86400))

    # RANGE is how far back in time to go, what the first value on the X-axis
    # should be if we scroll all the way to the beginning of the chart
    if [ "${SUFFIX}" == "yearly" ]; then
      RANGE=${RANGE_YEARLY}
      MULTFACT=31536000 # Yearly range is every 365 days
    elif [ "${SUFFIX}" == "monthly" ]; then
      RANGE=${RANGE_MONTHLY}
      MULTFACT=2628000 # Seconds in a year / 12 months
    elif [ "${SUFFIX}" == "weekly" ]; then
      RANGE=${RANGE_WEEKLY}
      MULTFACT=604800 # Seconds in a day * 7 days
      OFFSET=0 # No need for offset when dealing with weeks
    elif [ "${SUFFIX}" == "daily" ]; then
      RANGE=${RANGE_DAILY}
      MULTFACT=86400 # Seconds in 1 day
      OFFSET=0 # No need for offset when dealing with days
    fi
    STARTDATE=$((DATE - RANGE * MULTFACT))
    STARTDATE=$((STARTDATE - OFFSET))

    # Create a JS array with all the pertinent data first
    echo '<script>var data_'${SUFFIX}' = [' > ${HTMPATH}

    # Convert dates into a more easily identifiable format for .tmp file
    cat ${DBPATH} | while IFS=, read DBDATE USAGE
    do
      if [ "${SUFFIX}" == "yearly" ]; then
        LABEL=`date +\%Y -d @${DBDATE}`
      elif [ "${SUFFIX}" == "monthly" ]; then
        LABEL=`date +\%m-\%Y -d @${DBDATE}`
      elif [ "${SUFFIX}" == "weekly" ]; then
        LABEL=`date +\%V-\%Y -d @${DBDATE}`
      elif [ "${SUFFIX}" == "daily" ]; then
        LABEL=`date +\%Y-\%b-\%d -d @${DBDATE}`
      fi

      # Create a .tmp file with a collection of dates present in the DB file.
      # Ignore dates that go too far back in time (based on RANGE).
      DIFF=$((DATE - DBDATE))
      RANGEDIFF=$((DIFF / MULTFACT))
      if [ "$RANGEDIFF" -lt "$RANGE" ]; then
        echo "LABEL,"${LABEL},${DBDATE},${USAGE} >> /tmp/inrange_$$.tmp
      fi
    done

    # For each date in the RANGE, get data and generate label for X-axis tick.
    # Iterate through the whole RANGE in the DB file; if any tick mark's data
    # is missing, add a zero entry.
    CURRDATE=${STARTDATE}
    while [ ${CURRDATE} -lt $((DATE + MULTFACT)) ]; do
      # Get the date of this tick and format it to compare against today's date
      if [ "${SUFFIX}" == "yearly" ]; then
        LABEL=`date +\%Y -d @${CURRDATE}`
      elif [ "${SUFFIX}" == "monthly" ]; then
        LABEL=`date +\%m-\%Y -d @${CURRDATE}`
      elif [ "${SUFFIX}" == "weekly" ]; then
        LABEL=`date +\%V-\%Y -d @${CURRDATE}`
      elif [ "${SUFFIX}" == "daily" ]; then
        LABEL=`date +\%Y-\%b-\%d -d @${CURRDATE}`
      fi

      # If the iterator gets too far ahead, then it will match up with today.
      # We should break if that's the case (reached end of the X-axis).
      if [ "${CURRDATE}" -gt "${DATE}" ]; then
        DATECHECK=$((CURRDATE - MULTFACT)) # This should be one y/m/w/d behind
        DATECHECKYEAR=$(date +\%Y -d @${DATECHECK})
        DATECHECKMONTH=$(date +\%m-\%Y -d @${DATECHECK})
        DATECHECKWEEK=$(date +\%V-\%Y -d @${DATECHECK})
        DATECHECKDAY=$(date +\%d-\%m-\%Y -d @${DATECHECK})

        if ([ "${SUFFIX}" == "daily" ] && [ "${DATEIDDAY}" == "${DATECHECKDAY}" ]) || \
          ([ "${SUFFIX}" == "weekly" ] && [ "${DATEIDWEEK}" == "${DATECHECKWEEK}" ]) || \
          ([ "${SUFFIX}" == "monthly" ] && [ "${DATEIDMONTH}" == "${DATECHECKMONTH}" ]) || \
          ([ "${SUFFIX}" == "yearly" ] && [ "${DATEIDYEAR}" == "${DATECHECKYEAR}" ]); then
          break
        fi
      fi

      # If this tick mark's date has data in the DB file, get it (.tmp file)
      FOUND=""
      if [ -f /tmp/inrange_$$.tmp ]; then
        FOUND=`grep "LABEL,"$LABEL /tmp/inrange_$$.tmp`

        # In case there are unexpected multiple entries (e.g. more than one
        # label is found with 10-2016), use only the last most-recent one
        FOUND=`echo "${FOUND}" | tail -1 | head -1`
      fi

      # Make sure it's a valid date, according to AXISSTARTDATE (set in config)
      if [ ${CURRDATE} -gt ${AXISSTARTDATE} ]; then
        # If we have previous data to add to, retrieve it and add to it
        if [ "$FOUND" != "" ]; then
          DBDATE=$(echo ${FOUND} | cut -f3 -s -d, )
          PEAKUSAGE_IN=$(echo ${FOUND} | cut -f4 -s -d, )
          PEAKUSAGE_OUT=$(echo ${FOUND} | cut -f5 -s -d, )
          OFFPEAKUSAGE_IN=$(echo ${FOUND} | cut -f6 -s -d, )
          OFFPEAKUSAGE_OUT=$(echo ${FOUND} | cut -f7 -s -d, )

          DOWNTOTAL=$((PEAKUSAGE_IN + OFFPEAKUSAGE_IN))${UNITTOBYTES}
          UPTOTAL=$((PEAKUSAGE_OUT + OFFPEAKUSAGE_OUT))${UNITTOBYTES}
          GRANDTOTAL=$((PEAKUSAGE_IN+OFFPEAKUSAGE_IN+PEAKUSAGE_OUT+OFFPEAKUSAGE_OUT))$UNITTOBYTES

          # Write out the data for this tick mark into the JS array
          echo ${CURRDATE}', '${GRANDTOTAL}', '${DOWNTOTAL}', '${UPTOTAL}', ' >> ${HTMPATH}
        else
          # If this tick mark has no data (from DB file), put in a zero entry
          echo ${CURRDATE}', 0, 0, 0,' >> ${HTMPATH}
        fi
      fi

      # Increase iterator to next tick mark
      CURRDATE=$((CURRDATE + MULTFACT))
    done

    # Close the array and then use JS to reorganize the data for Chart.js
    echo '];

    var maxY_'${SUFFIX}' = 0;
    var labels_'${SUFFIX}' = [];
    var total_'${SUFFIX}' = [];
    var down_'${SUFFIX}' = [];
    var up_'${SUFFIX}' = [];
    for (var i = 0; i < data_'${SUFFIX}'.length; i += 4) {
      labels_'${SUFFIX}'.push(data_'${SUFFIX}'[i]);
      total_'${SUFFIX}'.push(data_'${SUFFIX}'[i + 1]);
      down_'${SUFFIX}'.push(data_'${SUFFIX}'[i + 2]);
      up_'${SUFFIX}'.push(data_'${SUFFIX}'[i + 3]);

      if (maxY_'${SUFFIX}' < data_'${SUFFIX}'[i + 1])
        maxY_'${SUFFIX}' = data_'${SUFFIX}'[i + 1];
    }

    </script>' >> ${HTMPATH}

    # Handle quotes/double-quotes
    TITLE=${TITLE//\'/\\\'}
    TITLE=${TITLE//\"/\\\"}

    # Chart.js code begins here
    echo '
      <div class="detailsChartWrapper">
          <canvas id="detailsChart-'${SUFFIX}'"></canvas>
          <button id="resetZoom-'${SUFFIX}'" class="reset-button" onclick="resetZoom(detailsChart_'${SUFFIX}', this);">Reset Zoom/Position</button>
      </div>
    ' >> ${HTMPATH}

    # AXISRANGE is no. of items shown on xAxis before having to zoom/pan/drag
    echo "<script>
      var minX_"${SUFFIX}" = labels_"${SUFFIX}"[labels_"${SUFFIX}".length - 1 - "${AXISRANGE}"];

      var ctx_"${SUFFIX}" = document.getElementById('detailsChart-"${SUFFIX}"');
      var detailsChart_"${SUFFIX}" = new Chart(ctx_"${SUFFIX}", {
        type: 'bar',
        data: {
          labels: labels_"${SUFFIX}",
          datasets: [
            {
              label: 'Total',
              data: total_"${SUFFIX}",
              backgroundColor: 'rgba(54, 162, 235, 0.2)',
              borderColor: 'rgba(54, 162, 235, 1)',
            },
            {
              label: 'Down',
              data: down_"${SUFFIX}",
              backgroundColor: 'rgba(120, 120, 120, 0.2)',
              borderColor: 'rgba(120, 120, 120, 1)',
            },
            {
              label: 'Up',
              data: up_"${SUFFIX}",
              backgroundColor: 'rgba(75, 192, 192, 0.2)',
              borderColor: 'rgba(75, 192, 192, 1)',
            },
          ]    
        },
        options: {
          responsive: true,
          elements: {
            bar: {
              borderWidth: 1,
            },
          },
          datasets: {
            bar: {
              barPercentage: 0.9,
              categoryPercentage: 0.7,
            },
          },
          scales: {
            x: {
              min: minX_"${SUFFIX}",
              ticks: {
                callback: function(value, index) {
                return formatDate('"${SUFFIX}"', new Date(this.getLabelForValue(value) * 1000));
                },
              },
            },
            y: {
              max: 1.05 * maxY_"${SUFFIX}",
              beginAtZero: true,
              title: {
                display: true,
                text: 'Bandwidth Used',
              },
              ticks: {
                callback: function(value, index, values) {
                  return getSize(value);
                },
              },
            },
          },
          plugins: {
            title: {
              display: true,
              text: \""${TITLE}"\",
              font: {
                size: 18,
              },
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  var label = context.dataset.label || '';
                  if (label) {
                    label += ': ';
                  }
                  label += getSize(context.parsed.y);
                  return label;
                },
                title: function(context) {
                  return formatDate('"${SUFFIX}"', new Date(context[0].label * 1000));
                },
              },
            },
            legend: {
              position: 'bottom',
            },
            zoom: {
              pan: {
                enabled: true,
                mode: 'xy',
                overScaleMode: 'y',
                speed: 1,
                rangeMin: {
                  y: 0,
                },
                onPan: function({chart}) {
                  var btn = document.getElementById('resetZoom-"${SUFFIX}"');
                  btn.style.display = 'block';
                },
              },
              zoom: {
                enabled: true,
                mode: 'xy',
                overScaleMode: 'y',
                rangeMin: {
                  y: 0,
                },
                rangeMax: {
                  y: 1.05 * maxY_"${SUFFIX}",
                },
                onZoom: function({chart}) {
                  var btn = document.getElementById('resetZoom-"${SUFFIX}"');
                  btn.style.display = 'block';
                },
              },
            },
          },
        }
      });</script>" >> ${HTMPATH}
  fi

  rm -f /tmp/inrange_$$.tmp

}

# Adds KB to daily/weekly/monthly/yearly DB files (specify amounts for IN/OUT)
updategraphdb()
{
  YEARDB=${1}
  MONTHDB=${2}
  WEEKDB=${3}
  DAYDB=${4}
  IN=${5}
  OUT=${6}
  OFFPEAK=${7}

  # Update chart totals for daily, weekly, monthly, yearly
  for DBPATH in "${DAYDB}" "${WEEKDB}" "${MONTHDB}" "${YEARDB}"
  do
    PEAKUSAGE_IN=0
    PEAKUSAGE_OUT=0
    OFFPEAKUSAGE_IN=0
    OFFPEAKUSAGE_OUT=0

    # Get last entry, if it exists
    LINE=`tail -1 $DBPATH | head -1`
    if [ ! -z "${LINE}" ]; then
      STOREDDATE=$(echo ${LINE} | cut -f1 -s -d, )

      if [ "${DBPATH}" == "${DAYDB}" ]; then
        DBSTORED=`date +\%d-\%m-\%Y -d @${STOREDDATE}`
        YMWD=${DATEIDDAY}
      elif [ "${DBPATH}" == "${WEEKDB}" ]; then
        DBSTORED=`date +\%V-\%Y -d @${STOREDDATE}`
        YMWD=${DATEIDWEEK}
      elif [ "${DBPATH}" == "${MONTHDB}" ]; then
        DBSTORED=`date +\%m-\%Y -d @${STOREDDATE}`
        YMWD=${DATEIDMONTH}
      elif [ "${DBPATH}" == "${YEARDB}" ]; then
        DBSTORED=`date +\%Y -d @${STOREDDATE}`
        YMWD=${DATEIDYEAR}
      fi

      # If the last line in the DB file has a date that still applies to today,
      # grab that data so we can update the numbers.
      if [ $DBSTORED == "${YMWD}" ]; then
        PEAKUSAGE_IN=$(echo ${LINE} | cut -f2 -s -d, )
        PEAKUSAGE_OUT=$(echo ${LINE} | cut -f3 -s -d, )
        OFFPEAKUSAGE_IN=$(echo ${LINE} | cut -f4 -s -d, )
        OFFPEAKUSAGE_OUT=$(echo ${LINE} | cut -f5 -s -d, )

        # Copy all but the last line to .tmp file. Basically discard this entry
        # so we can append it again later with the updated numbers.
        head -n -1 $DBPATH > /tmp/db_$$.tmp
      # If the last line doesn't have today's date, there's nothing to update or
      # discard. We just need to append a new line with the new numbers, so copy
      # over all previous numbers in this case.
      else
        cat $DBPATH > /tmp/db_$$.tmp
      fi
    fi

    # Add the KB of IN/OUT
    if [ "${OFFPEAK}" = "offpeak" ]; then
      OFFPEAKUSAGE_IN=$((${OFFPEAKUSAGE_IN}+${IN}))
      OFFPEAKUSAGE_OUT=$((${OFFPEAKUSAGE_OUT}+${OUT}))
    else
      PEAKUSAGE_IN=$((${PEAKUSAGE_IN}+${IN}))
      PEAKUSAGE_OUT=$((${PEAKUSAGE_OUT}+${OUT}))
    fi

    # Append new numbers to the .tmp file
    echo ${DATE},${PEAKUSAGE_IN},${PEAKUSAGE_OUT},${OFFPEAKUSAGE_IN},${OFFPEAKUSAGE_OUT} >> /tmp/db_$$.tmp

    # Rename .tmp file to be the DB file
    mv /tmp/db_$$.tmp $DBPATH
  done
}

# Advances to next day/week/month/year in the DB file if needed
checkreset()
{
  MAC=${1}
  REPORTSDBDIR=${2}

  MACDASHED=${MAC//:/-}
  for SUFFIX in daily weekly monthly yearly
  do
    DBFILE=${REPORTSDBDIR}/${MACDASHED}_${SUFFIX}.db

    # If the DB file already exists, check if we need to advance to next cycle
    if [ -f "$DBFILE" ]; then
      DBLASTLINE=`tail -1 ${DBFILE} | head -1`
      DBDATE=$(echo ${DBLASTLINE} | cut -f1 -s -d, )

      # Get the last date value from the DB file
      DATECHECKYEAR=$(date +\%Y -d @${DBDATE})
      DATECHECKMONTH=$(date +\%m-\%Y -d @${DBDATE})
      DATECHECKWEEK=$(date +\%V-\%Y -d @${DBDATE})
      DATECHECKDAY=$(date +\%d-\%m-\%Y -d @${DBDATE})

      # If it doesn't match today, it means we've entered a new cycle. Reset
      # counters and append a new line for the new day/week/month/year.
      if ([ "${SUFFIX}" == "daily" ] && [ ! "${DATEIDDAY}" == "${DATECHECKDAY}" ]) || \
        ([ "${SUFFIX}" == "weekly" ] && [ ! "${DATEIDWEEK}" == "${DATECHECKWEEK}" ]) || \
        ([ "${SUFFIX}" == "monthly" ] && [ ! "${DATEIDMONTH}" == "${DATECHECKMONTH}" ]) || \
        ([ "${SUFFIX}" == "yearly" ] && [ ! "${DATEIDYEAR}" == "${DATECHECKYEAR}" ]); then
        echo ${DATE},0,0,0,0 >> ${DBFILE}
      fi
    # If DB file doesn't exist yet, create a new file with zeroed-out counters
    else
      touch $DBFILE
      echo ${DATE},0,0,0,0 >> ${DBFILE}
    fi
  done
}

# Combines the daily/weekly/monthly/yearly HTM pages into a single tabbed page
publishdetailhtm()
{
  CSSPATH=${1}
  JSPATH=${2}
  DETAILHTM=${3}
  DAILYHTM=${4}
  WEEKLYHTM=${5}
  MONTHLYHTM=${6}
  YEARLYHTM=${7}
  TITLE=${8}

  # Start with a blank file and create everything from scratch
  > ${DETAILHTM}

  echo "<html>
    <head>
      <meta name=\"format-detection\" content=\"telephone=no\">
      <meta http-equiv=\"Pragma\" content=\"no-cache\">
      <meta http-equiv=\"Expires\" content=\"-1\">
      <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" />
      <title>"${TITLE}" Detail</title>
      <link rel=\"stylesheet\" href=\""$CSSPATH"/usage.css\" />
      <link rel=\"stylesheet\" href=\""$CSSPATH"/tabcontent/tabcontent.css\" />
      <script src=\""$JSPATH"/tabcontent.js\"></script>
      <script src=\""$JSPATH"/usage.js\"></script>
      <script src=\""$JSPATH"/chart.min.js\"></script>
      <script src=\""$JSPATH"/hammer.min.js\"></script>
      <script src=\""$JSPATH"/chartjs-plugin-zoom.min.js\"></script>
      <script>
        const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

        // dwmy - One of [\"daily\", \"weekly\", \"monthly\", \"yearly\"]
        // date - A Date object with the date data to display
        function formatDate(dwmy, date) {
          var day = ('0' + date.getDate()).slice(-2);
          var month = months[date.getMonth()];
          var year = date.getFullYear();
  
          if (dwmy === 'daily') {
              // Use an array so Chart.js puts in a newline
              return [year + '-' + month + '-' + day, '(' + days[date.getDay()] + ')'];
          }
          else if (dwmy === 'weekly') {
              // Get previous Monday, since that is when the ISO week starts
              date.setDate(date.getDate() - (date.getDay() + 6) % 7);

              var start_day = ('0' + date.getDate()).slice(-2);
              var start_month = months[date.getMonth()];
              var start_year = date.getFullYear();

              // Get following Sunday (end of the ISO week)
              date.setDate(date.getDate() + 6);

              var end_day = ('0' + date.getDate()).slice(-2);
              var end_month = months[date.getMonth()];
              var end_year = date.getFullYear();

              // Use an array so Chart.js puts in a newline
              return [start_year + '-' + start_month + '-' + start_day + ' to ', end_year + '-' + end_month + '-' + end_day];
          }
          else if (dwmy === 'monthly') {
              return month + '-' + year;
          }
          else if (dwmy === 'yearly') {
              return year;
          }
        }

        function resetZoom(chart, btn) {
          chart.resetZoom();
          btn.style.display = 'none';
        }
      </script>
    </head>

    <body>
      <h1>"${TITLE}"<br><span class=\"text-small\">"${PAGETITLE}"</span></h1>
      <span class="back-link" onclick=\"window.history.back();\">&laquo; Back</span>
      <ul class=\"tabs\" data-persist=\"false\">
        <li><a href=\"\#daily\">Daily</a></li>
        <li><a href=\"\#weekly\">Weekly</a></li>
        <li><a href=\"\#monthly\">Monthly</a></li>
        <li><a href=\"\#yearly\">Yearly</a></li>
      </ul>
  " >> ${DETAILHTM}
  echo "<div class=\"tabcontents\">" >> ${DETAILHTM}
  echo "<div id=\"daily\">" >> ${DETAILHTM}
  cat ${DAILYHTM} >> ${DETAILHTM}
  echo "</div>" >> ${DETAILHTM}
  echo "<div id=\"weekly\">" >> ${DETAILHTM}
  cat ${WEEKLYHTM} >> ${DETAILHTM}
  echo "</div>" >> ${DETAILHTM}
  echo "<div id=\"monthly\">" >> ${DETAILHTM}
  cat ${MONTHLYHTM} >> ${DETAILHTM}
  echo "</div>" >> ${DETAILHTM}
  echo "<div id=\"yearly\">" >> ${DETAILHTM}
  cat ${YEARLYHTM} >> ${DETAILHTM}
  echo "</div>" >> ${DETAILHTM}
  echo "</div></body></html>" >> ${DETAILHTM}
}

# Creates the HTML for a watch list. Also shuts down or restores connections
# based on the set quota
publishWatchList()
{
  TOTALSDB=${1}
  WATCHLISTHTM=${2}
  WATCHLISTARRAY=${3}
  MBQUOTAPER=${4}
  WATCHLISTTITLE=${5}

  # Handle quotes/double-quotes
  WATCHLISTTITLE=${WATCHLISTTITLE//\'/\\\'}
  WATCHLISTTITLE=${WATCHLISTTITLE//\"/\\\"}

  if [ "$MBQUOTAPER" != "" ]; then

    echo 'var watchList = {' >> ${WATCHLISTHTM}

    for name in $WATCHLISTARRAY ; do
      # Handle quotes/double-quotes
      ESCAPED_NAME=${name//\'/\\\'}
      ESCAPED_NAME=${ESCAPED_NAME//\"/\\\"}

      echo '"'${ESCAPED_NAME}'": 0, ' >> ${WATCHLISTHTM}

      # If the name is prefixed with specified string, don't shut off their
      # connection -- but DO restore their connection
      SKIPSTR="SKIP_" # the prefix
      SKIPNAME=0      # a flag
      if [ ! "${name/$SKIPSTR}" = "$name" ] ; then
        SKIPNAME=1
        name=$(echo $name | cut -f2 -s -d'_')
      fi

      > /tmp/uadt_macs.tmp # empty the file first!

      # A trick to get a single variable's value out of the while-loop; note
      # "tail -n 1" pipe and "echo $USERALLDEVICESTOTAL" inside loop
      USERALLDEVICESTOTAL=0

      if grep -iq $name ${TOTALSDB}; then
      USERALLDEVICESTOTAL=`
      grep -i $name ${TOTALSDB} | while IFS=, read USER USAGE MAC
      do
        USERALLDEVICESTOTAL=$((USERALLDEVICESTOTAL + USAGE))
        echo ${MAC} >> /tmp/uadt_macs.tmp
        echo $USERALLDEVICESTOTAL
      done | tail -n 1
      `
      fi

      # Convert to MB if unit is KB, since config file numbers are all in MB
      if  [ "${UNIT}" == "KB" ]; then
        USERALLDEVICESTOTAL=$((USERALLDEVICESTOTAL / 1000))
      fi

      if [ $USERALLDEVICESTOTAL -ne 0 ]; then
        if [ "${USERALLDEVICESTOTAL}" -gt "${MBQUOTAPER}" ]; then
          echo "QUOTA : "${WATCHLISTTITLE}" : "${name}" has reached quota limit!"
          if [ $SKIPNAME -eq 0 ] ; then
            cat /tmp/uadt_macs.tmp | while IFS= read MAC
            do
              echo "  "${MAC}" cut off"
              iptables -I FORWARD -m mac --mac-source ${MAC} -j DROP -w
            done
          else
            echo "  config file says skip, so resume connection!"
            cat /tmp/uadt_macs.tmp | while IFS= read MAC
            do
              iptables -I FORWARD -m mac --mac-source ${MAC} -j ACCEPT -w
            done
          fi
        else
          # Not over quota, so resume connection
          echo "QUOTA : "${WATCHLISTTITLE}" : "${name}" is below quota"
          echo "  not over quota, resume connection"
          cat /tmp/uadt_macs.tmp | while IFS= read MAC
          do
            iptables -I FORWARD -m mac --mac-source ${MAC} -j ACCEPT -w
          done
        fi
      fi
    done
  
    rm -f /tmp/uadt_macs.tmp
  
    echo '};
    for (var i = 0; i < values.length; i++) {
      var val = values[i];
      if (val[0] != null) {
        for (var key in watchList) {
          var currentKey = key.toLowerCase();
          var skipstr = "'${SKIPSTR}'";
          skipstr = skipstr.toLowerCase();
          if (currentKey.indexOf(skipstr) != -1) {
            currentKey = currentKey.replace(skipstr, "");
          }
          if (val[0].toLowerCase().indexOf(currentKey) != -1) {
            watchList[key] += val[6];
          }
        }
      }
    }' >> ${WATCHLISTHTM}
  
    echo 'var watchListOverA = new Array();
    var watchListOverB = new Array();
    var watchListOverC = new Array();' >> ${WATCHLISTHTM}

    # Keep in mind that all size values in the JS are in bytes, so convert
    # MBQUOTEPER accordingly
    echo "for (var key in watchList) {
    if (watchList[key] > "${MBQUOTAPER}"000000) {
      var skipstr = \""${SKIPSTR}"\";
      var keyLabel = key;
      if (key.indexOf(skipstr) != -1) {
        keyLabel = key.replace(skipstr, \"\");
      }
    else {
      keyLabel = key + \" <b class='red'>[OFF]</b>\";
    }
    watchListOverA.push(keyLabel + ' ('+getSize(watchList[key])+')');
  }
      else if (watchList[key] > "$((MBQUOTAPER - WATCHLISTSTEP))"000000 && "${MBQUOTAPER}" > ${WATCHLISTSTEP}) {
        watchListOverB.push(key + ' ('+getSize(watchList[key])+')');
      }
  else if (watchList[key] > "$((MBQUOTAPER - (WATCHLISTSTEP * 2)))"000000 && "${MBQUOTAPER}" > $((WATCHLISTSTEP * 2))) {
      watchListOverC.push(key + ' ('+getSize(watchList[key])+')');
    }
  }" >> ${WATCHLISTHTM}
    echo "if (watchListOverA.length || watchListOverB.length || watchListOverC.length) {" >> ${WATCHLISTHTM}
    echo "document.write('<h4>"${WATCHLISTTITLE}" <span class=\"purple\">(Quota: '+getSize("${MBQUOTAPER}"000000)+')</span></h4>');" >> ${WATCHLISTHTM}
    echo "document.write('<table id=\"overtable\"><tr>');" >> ${WATCHLISTHTM}
    echo "if (watchListOverA.length) " >> ${WATCHLISTHTM}
    echo "document.write('<td width=\"20%\" class=\"rowlabel\">Over '+getSize("${MBQUOTAPER}"000000)+'</td><td>'+watchListOverA.join(\", \")+'</td></tr>');" >> ${WATCHLISTHTM}
    echo "if (watchListOverB.length) " >> ${WATCHLISTHTM}
    echo "document.write('<td width=\"20%\" class=\"rowlabel\">Over '+getSize("$((MBQUOTAPER - WATCHLISTSTEP))"000000)+'</td><td>'+watchListOverB.join(\", \")+'</td></tr>');" >> ${WATCHLISTHTM}
    echo "if (watchListOverC.length) " >> ${WATCHLISTHTM}
    echo "document.write('<td width=\"20%\" class=\"rowlabel\">Over '+getSize("$((MBQUOTAPER - (WATCHLISTSTEP * 2)))"000000)+'</td><td>'+watchListOverC.join(\", \")+'</td></tr>');" >> ${WATCHLISTHTM}
    echo "document.write('</table>');" >> ${WATCHLISTHTM}
    echo "}" >> ${WATCHLISTHTM}
  fi
}

case ${1} in

"setup" )

    # Create the RRDIPT CHAIN (it doesn't matter if it already exists)
    iptables -N RRDIPT -w 2> /dev/null

    # Add the RRDIPT CHAIN to the FORWARD chain (if non existing)
    iptables -L FORWARD --line-numbers -n -w | grep "RRDIPT" | grep "1" > /dev/null
    if [ $? -ne 0 ]; then
        iptables -L FORWARD -n -w | grep "RRDIPT" > /dev/null
        if [ $? -eq 0 ]; then
            echo "DEBUG : iptables chain misplaced, recreating it..."
            iptables -D FORWARD -j RRDIPT -w
        fi
        iptables -I FORWARD -j RRDIPT -w
    fi

    # For each host in the ARP table
    grep ${LAN_IFACE} /proc/net/arp | while read IP TYPE FLAGS MAC MASK IFACE
    do
        # Add iptable rules (if non-existing)
        iptables -nL RRDIPT -w | grep "${IP} " > /dev/null
        if [ $? -ne 0 ]; then
            iptables -I RRDIPT -d ${IP} -j RETURN -w
            iptables -I RRDIPT -s ${IP} -j RETURN -w
        fi
    done    
    ;;
    
"update" )

    [ -z "${2}" ] && echo "ERROR : Missing argument 2" && exit 1
    [ -f "${2}" ] || echo "COUNTERSTART",0,0,0,0,${DATE} >> ${2}

    # Path to directory to write the daily/weekly/monthly/yearly DB data
    [ -z "${3}" ] && echo "ERROR : Missing argument 3" && exit 1
    REPORTSDBDIR=${3}
    [ -d ${REPORTSDBDIR} ] || mkdir -p ${REPORTSDBDIR}

    OFFPEAK="peak"
    [ -z "${4}" ] || OFFPEAK=${4}

    KEEPMAC="forget"
    [ -z "${5}" ] || KEEPMAC=${5}

    lock

    # Read and reset counters
    iptables -L RRDIPT -vnxZ -t filter -w > /tmp/traffic_$$.tmp

    # sed '1d' removes the first line (i.e. column headers: IP address, HW type, Flags, HW address, Mask Device)
    grep -v "0x0" /proc/net/arp | sed '1d' | grep ${DEVICEFILTER} | while read IP TYPE FLAGS MAC MASK IFACE
    do
        # Add new data to the chart. Have to use temporary files because of
        # crappy busybox shell (ash)

        # Get around this problem with Solution 3: http://www.linuxprogrammingblog.com/pipe-in-bash-can-be-a-trap
        IN=`
        grep ${IP} /tmp/traffic_$$.tmp | while read PKTS BYTES TARGET PROT OPT IFIN IFOUT SRC DST
        do
            if ([ "${DST}" = "${IP}" ] && [ "${BYTES}" != 0 ]); then
                IN=$((${BYTES}/1000))
                echo $IN
            fi
        done | tail -n 1
        `

        OUT=`
        grep ${IP} /tmp/traffic_$$.tmp | while read PKTS BYTES TARGET PROT OPT IFIN IFOUT SRC DST
        do
            if ([ "${SRC}" = "${IP}" ] && [ "${BYTES}" != 0 ]); then
                OUT=$((${BYTES}/1000))
                echo $OUT
            fi
        done | tail -n 1
        `

        # Make sure we don't get an arithmetic syntax error
        [ "${IN}" == "" ] && IN=0
        [ "${OUT}" == "" ] && OUT=0

        if  [ "${UNIT}" == "MB" ]; then
          # Round-down if size is less than 1 MB. Can't use floats.
          [ ${IN} -lt 1000 ] && IN=0
          [ ${OUT} -lt 1000 ] && OUT=0

          # Divide again to MB
          IN=$((${IN}/1000))
          OUT=$((${OUT}/1000))
        fi

        if ([ ! ${IN} == 0 ] || [ ! ${OUT} == 0 ]);  then
            echo "DEBUG : New traffic for ${MAC} since last update : Down: ${IN} ${UNIT}, Up: ${OUT} ${UNIT}"
        
            LINE=$(grep ${MAC} ${2})
            if [ -z "${LINE}" ]; then
                echo "DEBUG : ${MAC} is a new host !"
                PEAKUSAGE_IN=0
                PEAKUSAGE_OUT=0
                OFFPEAKUSAGE_IN=0
                OFFPEAKUSAGE_OUT=0
            else
                PEAKUSAGE_IN=$(echo ${LINE} | cut -f2 -s -d, )
                PEAKUSAGE_OUT=$(echo ${LINE} | cut -f3 -s -d, )
                OFFPEAKUSAGE_IN=$(echo ${LINE} | cut -f4 -s -d, )
                OFFPEAKUSAGE_OUT=$(echo ${LINE} | cut -f5 -s -d, )
            fi

            if [ "${OFFPEAK}" = "offpeak" ]; then
                OFFPEAKUSAGE_IN=$((${OFFPEAKUSAGE_IN}+${IN}))
                OFFPEAKUSAGE_OUT=$((${OFFPEAKUSAGE_OUT}+${OUT}))
            else
                PEAKUSAGE_IN=$((${PEAKUSAGE_IN}+${IN}))
                PEAKUSAGE_OUT=$((${PEAKUSAGE_OUT}+${OUT}))
            fi

            grep -v "${MAC}" ${2} > /tmp/db_$$.tmp
            mv /tmp/db_$$.tmp ${2}

            echo ${MAC},${PEAKUSAGE_IN},${PEAKUSAGE_OUT},${OFFPEAKUSAGE_IN},${OFFPEAKUSAGE_OUT},${DATE} >> ${2}

            ###############################################
            ### Update daily/weekly/yearly/monthly data ###
            ###############################################

            # Check each DB file of this MAC address to see if we need to reset
            # counters and advance to a new line
            checkreset "${MAC}" "${REPORTSDBDIR}"

            # Get rid of colons; replace with dashes so we can use in filename
            MACDASHED=${MAC//:/-}

            # Create files to store data if they don't exist yet
            YEARDB=${REPORTSDBDIR}/${MACDASHED}_yearly.db
            [ -f "$YEARDB" ] || touch $YEARDB
            MONTHDB=${REPORTSDBDIR}/${MACDASHED}_monthly.db
            [ -f "$MONTHDB" ] || touch $MONTHDB
            WEEKDB=${REPORTSDBDIR}/${MACDASHED}_weekly.db
            [ -f "$WEEKDB" ] || touch $WEEKDB
            DAYDB=${REPORTSDBDIR}/${MACDASHED}_daily.db
            [ -f "$DAYDB" ] || touch $DAYDB
            updategraphdb "${YEARDB}" "${MONTHDB}" "${WEEKDB}" "${DAYDB}" "${IN}" "${OUT}" "${OFFPEAK}"

            # Grand totals update
            YEARDB=${REPORTSDBDIR}/yearly.db
            [ -f "$YEARDB" ] || touch $YEARDB
            MONTHDB=${REPORTSDBDIR}/monthly.db
            [ -f "$MONTHDB" ] || touch $MONTHDB
            WEEKDB=${REPORTSDBDIR}/weekly.db
            [ -f "$WEEKDB" ] || touch $WEEKDB
            DAYDB=${REPORTSDBDIR}/daily.db
            [ -f "$DAYDB" ] || touch $DAYDB
            updategraphdb "${YEARDB}" "${MONTHDB}" "${WEEKDB}" "${DAYDB}" "${IN}" "${OUT}" "${OFFPEAK}"
        fi
    done
    
    # Free some memory
    rm -f /tmp/*_$$.tmp
    unlock
    ;;
    
"reset" | "backup" )

    ##################################
    ### START OF ARGUMENTS SECTION ###
    ##################################

    # Database file
    [ -z "${2}" ] && echo "ERROR : Missing argument 2" && exit 1
    [ ! -f "${2}" ] && echo "ERROR : Database file ${2} does not exist" && exit 1

    # Directory of daily/weekly/monthly/yearly database files
    [ -z "${3}" ] && echo "ERROR : Missing argument 3" && exit 1
    REPORTSDBDIR=${3}

    # Path to backup to
    [ -z "${4}" ] && echo "ERROR : Missing argument 4" && exit 1
    [ -d "${4}" ] || mkdir -p ${4}
    BACKUPDIR=${4}

    # Users file
    [ -z "${5}" ] && echo "ERROR : Missing argument 5" && exit 1
    USERSFILE=${5}

    # Keep or forget MAC addresses in usage.db (doesn't affect userfile)
    [ -z "${6}" ] && echo "ERROR : Missing argument 6" && exit 1
    KEEPMAC=${6}

    # Optional 7th parameter specifies a directory to purge

    ################################
    ### END OF ARGUMENTS SECTION ###
    ################################
    
    lock

    # Make backups
    DEST=${BACKUPDIR}/$DATESTAMPYEAR
    [ -d ${DEST} ] || mkdir $DEST
    DEST=${DEST}/$DATESTAMPMONTH
    [ -d ${DEST} ] || mkdir $DEST
    DEST=${DEST}/$DATESTAMPDAY
    [ -d ${DEST} ] || mkdir $DEST
    DEST=${DEST}/$DATESTAMPTIME
    [ -d ${DEST} ] || mkdir $DEST

    cp ${2} ${DEST}
    [ -f "${USERSFILE}" ] && cp ${USERSFILE} ${DEST}
    [ -d "${REPORTSDBDIR}" ] && cp -r ${REPORTSDBDIR} ${DEST}

    [ "${1}" == "backup" ] && echo "DEBUG : backup complete " && exit 1

    # Now handle extra steps for non-backup options
    echo "COUNTERSTART",0,0,0,0,${DATE} > /tmp/db_$$.tmp

    if [ ! "${KEEPMAC}" == "forget" ]; then
      cat ${2} | while IFS=, read MAC PEAKUSAGE_IN PEAKUSAGE_OUT OFFPEAKUSAGE_IN OFFPEAKUSAGE_OUT LASTUPDATE
      do
        if [ ! ${MAC} == "COUNTERSTART" ]; then
          echo ${MAC},0,0,0,0,${DATE} >> /tmp/db_$$.tmp
        fi
      done
    fi

    # This zeroes out the counters of usage.db
    mv /tmp/db_$$.tmp ${2}

    # Also reset anybody's connection that was cut off
    iptables -F -w

    # Reset numbers for daily
    find ${REPORTSDBDIR} -type f -name "*daily.db" | while read DBFILE; do
      LINE=`tail -1 $DBFILE | head -1`
      STOREDDATE=$(echo ${LINE} | cut -f1 -s -d, )
      DBSTORED=`date +\%d-\%m-\%Y -d @${STOREDDATE}`

      # If we're still in today, copy all but today's numbers
      if [ "${DBSTORED}" == "${DATEIDDAY}" ]; then
        head -n -1 $DBFILE > /tmp/db_$$.tmp
      # Otherwise copy everything
      else
        cat $DBFILE > /tmp/db_$$.tmp
      fi

      # Now append today's entry, with all counters reset to zero
      echo ${DATE},0,0,0,0 >> /tmp/db_$$.tmp

      # Rename the .tmp file into the DB file
      mv /tmp/db_$$.tmp $DBFILE
    done

    # Optionally-specified backup directory to purge
    [ -z "${7}" ] || rm -rf ${7}/*

    unlock
    ;;

"publish" )

    ##################################
    ### START OF ARGUMENTS SECTION ###
    ##################################

    # Database file
    [ -z "${2}" ] && echo "ERROR : Missing argument 2" && exit 1
    [ ! -f "${2}" ] && echo "ERROR : Database file ${2} does not exist" && exit 1

    # Directory of database files
    [ -z "${3}" ] && echo "ERROR : Missing argument 3" && exit 1
    [ ! -d "${3}" ] && echo "ERROR : Invalid reports database directory ${3}" && exit 1
    REPORTSDBDIR=${3}

    # .htm directory to publish main total usage page
    [ -z "${4}" ] && echo "ERROR : Missing argument 4" && exit 1
    [ -d "${4}" ] || mkdir -p ${4}
    USAGEHTM=${4}/usage.htm
    TMPUSAGEHTM=/tmp/usage_$$.tmp

    [ -z "${5}" ] || USERSFILE=${5}
    [ -f "${USERSFILE}" ] || USERSFILE="/dev/null"

    ################################
    ### END OF ARGUMENTS SECTION ###
    ################################

    # Directory to publish .htm reports
    REPORTSHTMDIR=${4}/reports
    [ -d "${REPORTSHTMDIR}" ] || mkdir -p ${REPORTSHTMDIR}

    DNSMASQFILE="/etc/dnsmasq.conf"
    [ -f "${DNSMASQFILE}" ] || DNSMASQFILE="/tmp/dnsmasq.leases"
    [ -f "${DNSMASQFILE}" ] || DNSMASQFILE="/dev/null"

    # first do some number crunching - rewrite the database so that it is sorted
    lock
    touch /tmp/sorted_$$.tmp
    GRANDTOTAL=0
    GRANDDOWN=0
    GRANDUP=0
    GRANDPEAKIN=0
    GRANDPEAKOUT=0
    GRANDOFFPEAKIN=0
    GRANDOFFPEAKOUT=0
    cat ${2} | while IFS=, read MAC PEAKUSAGE_IN PEAKUSAGE_OUT OFFPEAKUSAGE_IN OFFPEAKUSAGE_OUT LASTUPDATE
    do


      # COUNTERSTART value should only be on the first line of the .db file
      if [ ${MAC} == "COUNTERSTART" ]; then
        # We want the COUNTERSTART line sorted to the end of the array,
        # so give it the smallest size (we sort by USERTOTAL in 'publish').
        USERTOTAL=-1

        DOWNTOTAL=0
        UPTOTAL=0
        PEAKUSAGE_IN=0
        PEAKUSAGE_OUT=0
        OFFPEAKUSAGE_IN=0
        OFFPEAKUSAGE_OUT=0

        echo ${USERTOTAL},${DOWNTOTAL},${UPTOTAL},${PEAKUSAGE_IN},${PEAKUSAGE_OUT},${OFFPEAKUSAGE_IN},${OFFPEAKUSAGE_OUT},${MAC},$(date "+%a %b-%d %H:%M %Z %Y" -d @$LASTUPDATE).${LASTUPDATE},${GRANDDOWN},${GRANDUP},${GRANDTOTAL},${GRANDPEAKIN},${GRANDPEAKOUT},${GRANDOFFPEAKIN},${GRANDOFFPEAKOUT} >> /tmp/sorted_$$.tmp
      else
        DOWNTOTAL=$((PEAKUSAGE_IN + OFFPEAKUSAGE_IN))
        UPTOTAL=$((PEAKUSAGE_OUT + OFFPEAKUSAGE_OUT))
        USERTOTAL=$((DOWNTOTAL + UPTOTAL))

        GRANDDOWN=$((GRANDDOWN + DOWNTOTAL))
        GRANDUP=$((GRANDUP + UPTOTAL))
        GRANDTOTAL=$((GRANDTOTAL + USERTOTAL))
        GRANDPEAKIN=$((GRANDPEAKIN + PEAKUSAGE_IN))
        GRANDPEAKOUT=$((GRANDPEAKOUT + PEAKUSAGE_OUT))
        GRANDOFFPEAKIN=$((GRANDOFFPEAKIN + OFFPEAKUSAGE_IN))
        GRANDOFFPEAKOUT=$((GRANDOFFPEAKOUT + OFFPEAKUSAGE_OUT))

        echo ${USERTOTAL},${DOWNTOTAL},${UPTOTAL},${PEAKUSAGE_IN},${PEAKUSAGE_OUT},${OFFPEAKUSAGE_IN},${OFFPEAKUSAGE_OUT},${MAC},$(date "+%b-%d %H:%M" -d @$LASTUPDATE).${LASTUPDATE},${GRANDDOWN},${GRANDUP},${GRANDTOTAL},${GRANDPEAKIN},${GRANDPEAKOUT},${GRANDOFFPEAKIN},${GRANDOFFPEAKOUT} >> /tmp/sorted_$$.tmp
      fi

    done
    unlock
        # create HTML page
        echo "<html>
          <head>
            <meta http-equiv=\"Pragma\" content=\"no-cache\">
            <meta http-equiv=\"Expires\" content=\"-1\">
            <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" />
            <title>Traffic</title>
            <link rel=\"stylesheet\" href=\"css/usage.css\" />
            <script src=\"js/usage.js\"></script>
            <script src=\"js/sorttable.js\"></script>
            <script src=\"js/tablefilter.js\"></script>
            <script>
              document.onkeydown = function(evt) {
                resetFilterKeypress(evt, \""${ROUTERNAME}"\");
              };</script>
          </head>
          <body>" >> $TMPUSAGEHTM
        echo "<h1>"${PAGETITLE}"</h1>" >> $TMPUSAGEHTM
        echo "<script>" >> $TMPUSAGEHTM

        TOTALSDB=/tmp/totalsdb.tmp
        > $TOTALSDB

        echo "var values = new Array(" >> $TMPUSAGEHTM
        sort -n -r /tmp/sorted_$$.tmp | while IFS=, read USERTOTAL DOWNTOTAL UPTOTAL PEAKUSAGE_IN PEAKUSAGE_OUT OFFPEAKUSAGE_IN OFFPEAKUSAGE_OUT MAC LASTUPDATE GRANDNUMS
        do
                echo "new Array(" >> $TMPUSAGEHTM
                USER=$(grep "${MAC}" "${USERSFILE}" | cut -f2 -s -d, )
                DNSMASQUSER=$(grep "${MAC}" "${DNSMASQFILE}" | cut -f4 -s -d ' ')

                # If USER is not defined in /tmp/users.txt or the router has
                # assigned the name "*", then there is no username, so assign
                # the username of "UNKNOWN"
                if [ -z "$USER" ] || [ "$USER" == "*" ]; then
                  USER="UNKNOWN"
                fi

                # Store the original unsuffixed username. We will be suffixing
                # the username with "_warning" or "_alert" for specific CSS
                # styling (classes will be added by JS) if the user isn't
                # defined in the /tmp/users.txt file.
                ORIGUSER=$USER

                # If the user is unknown but there is a name defined by
                # DNSMASQUSER, use that name instead. Update the unsuffixed
                # name (ORIGUSER) and then suffix with "_warning".
                if [ "$USER" == "UNKNOWN" ] && [ ! -z "$DNSMASQUSER" ] && [ ! "$DNSMASQUSER" == "*" ]; then
                  ORIGUSER=$DNSMASQUSER
                  USER="${DNSMASQUSER}_warning"
                fi 

                # If the user is still unknown, suffix with "_alert"
                if [ "$USER" == "UNKNOWN" ] ; then
                  USER=${USER}_alert
                fi

                echo ${USER},${USERTOTAL},${MAC} >> $TOTALSDB

                # Make sure quotes/double-quotes are escaped
                USER=${USER//\'/\\\'}
                USER=${USER//\"/\\\"}

                echo "\"${USER}\",\"${MAC}\",${PEAKUSAGE_IN}${UNITTOBYTES},${PEAKUSAGE_OUT}${UNITTOBYTES},${OFFPEAKUSAGE_IN}${UNITTOBYTES},${OFFPEAKUSAGE_OUT}${UNITTOBYTES},${USERTOTAL}${UNITTOBYTES},${DOWNTOTAL}${UNITTOBYTES},${UPTOTAL}${UNITTOBYTES},\"${LASTUPDATE}\"" >> $TMPUSAGEHTM

                #########################################################
                ### Publish to daily/weekly/monthly/yearly HTML pages ###
                #########################################################

                if [ ! ${MAC} == "COUNTERSTART" ] && [ ! ${MAC} == "00:00:00:00:00:00" ]; then
                  # Get rid of colons; replace with dashes
                  MACDASHED=${MAC//:/-}

                  # Create HTM directory for this device if it does not yet exist
                  [ -d ${REPORTSHTMDIR}/${MACDASHED} ] || mkdir -p ${REPORTSHTMDIR}/${MACDASHED}

                  for SUFFIX in daily weekly monthly yearly
                  do
                    TITLE=${ORIGUSER}" ("${MAC}")"
                    HTMPATH=${REPORTSHTMDIR}/${MACDASHED}/${SUFFIX}_detail.htm
                    DBPATH=${REPORTSDBDIR}/${MACDASHED}_${SUFFIX}.db

                    [ -s "${DBPATH}" ] || echo "No "${SUFFIX}" data published yet." > $HTMPATH

                    if [ "${SUFFIX}" == "yearly" ]; then
                      SUFFIXCAP="Yearly"
                      AXISRANGE=${AXISRANGE_YEARLY}
                    elif [ "${SUFFIX}" == "monthly" ]; then
                      SUFFIXCAP="Monthly"
                      AXISRANGE=${AXISRANGE_MONTHLY}
                    elif [ "${SUFFIX}" == "weekly" ]; then
                      SUFFIXCAP="Weekly"
                      AXISRANGE=${AXISRANGE_WEEKLY}
                    elif [ "${SUFFIX}" == "daily" ]; then
                      SUFFIXCAP="Daily"
                      AXISRANGE=${AXISRANGE_DAILY}
                    fi

                    publishgraphhtm "${DBPATH}" "${SUFFIX}" "${HTMPATH}" "${SUFFIXCAP} Usage for ${TITLE}" "${AXISRANGE}" "${MAC}"
                  done

                  DETAILHTM=${REPORTSHTMDIR}/${MACDASHED}/detail.htm
                  [ -f "$DETAILHTM" ] || touch $DETAILHTM
                  YEARLYHTM=${REPORTSHTMDIR}/${MACDASHED}/yearly_detail.htm
                  MONTHLYHTM=${REPORTSHTMDIR}/${MACDASHED}/monthly_detail.htm
                  WEEKLYHTM=${REPORTSHTMDIR}/${MACDASHED}/weekly_detail.htm
                  DAILYHTM=${REPORTSHTMDIR}/${MACDASHED}/daily_detail.htm
                  TITLE=${ORIGUSER}" ("${MAC}")"

                  CSSPATH=../../css
                  JSPATH=../../js

                  publishdetailhtm "${CSSPATH}" "${JSPATH}" "${DETAILHTM}" "${DAILYHTM}" "${WEEKLYHTM}" "${MONTHLYHTM}" "${YEARLYHTM}" "${TITLE}"

                  DBPATH=${REPORTSDBDIR}/${MACDASHED}_daily.db
                  LASTUPDATERAW=$(echo ${LASTUPDATE} | cut -f2 -s -d. )
                  LASTUPDATEDAY=`date +\%d -d @${LASTUPDATERAW}`
                  LASTUPDATEMONTH=`date +\%m -d @${LASTUPDATERAW}`
                  LASTUPDATEYEAR=`date +\%Y -d @${LASTUPDATERAW}`
                  if [ -f ${DBPATH} ] && [ ${LASTUPDATEDAY} == ${DATESTAMPDAY} ] &&  [ ${LASTUPDATEMONTH} == ${DATESTAMPMONTH} ] && [ ${LASTUPDATEYEAR} == ${DATESTAMPYEAR} ]; then
                    TODAYNUMS=`tail -1 ${DBPATH}`
                    TODAYPEAKUSAGE_IN=$(echo ${TODAYNUMS} | cut -f2 -s -d, )
                    TODAYPEAKUSAGE_OUT=$(echo ${TODAYNUMS} | cut -f3 -s -d, )
                    TODAYOFFPEAKUSAGE_IN=$(echo ${TODAYNUMS} | cut -f4 -s -d, )
                    TODAYOFFPEAKUSAGE_OUT=$(echo ${TODAYNUMS} | cut -f5 -s -d, )
                    TODAYDOWN=$((TODAYPEAKUSAGE_IN + TODAYOFFPEAKUSAGE_IN))
                    TODAYUP=$((TODAYPEAKUSAGE_OUT + TODAYOFFPEAKUSAGE_OUT))
                    TODAYTOTAL=$((TODAYDOWN + TODAYUP))

                    echo ","${TODAYTOTAL}${UNITTOBYTES},${TODAYDOWN}${UNITTOBYTES},${TODAYUP}${UNITTOBYTES} >> $TMPUSAGEHTM
                  else
                    echo ",0,0,0" >> $TMPUSAGEHTM
                  fi
                fi

                echo ")," >> $TMPUSAGEHTM

        done
        echo "0);" >> $TMPUSAGEHTM

        # Publish individual watch lists
        publishWatchList "${TOTALSDB}" "${TMPUSAGEHTM}" "${STUDENTWATCHLISTARRAY}" "${MBQUOTAPERSTUDENT}" "${STUDENTWATCHLISTTITLE}"
        publishWatchList "${TOTALSDB}" "${TMPUSAGEHTM}" "${GUESTWATCHLISTARRAY}" "${MBQUOTAPERGUEST}" "${GUESTWATCHLISTTITLE}"

        rm -f /tmp/totalsdb.tmp

        # Grand Total Today numbers handled separately
        DBPATH=${REPORTSDBDIR}/daily.db
        if [ -f ${DBPATH} ]; then
          TODAYNUMS=`tail -1 ${DBPATH}`
          LASTUPDATERAW=$(echo ${TODAYNUMS} | cut -f1 -s -d, )
          LASTUPDATEDAY=`date +\%d -d @${LASTUPDATERAW}`
          LASTUPDATEMONTH=`date +\%m -d @${LASTUPDATERAW}`
          LASTUPDATEYEAR=`date +\%Y -d @${LASTUPDATERAW}`
          if [ ${LASTUPDATEDAY} == ${DATESTAMPDAY} ] &&  [ ${LASTUPDATEMONTH} == ${DATESTAMPMONTH} ] && [ ${LASTUPDATEYEAR} == ${DATESTAMPYEAR} ]; then
            TODAYPEAKUSAGE_IN=$(echo ${TODAYNUMS} | cut -f2 -s -d, )
            TODAYPEAKUSAGE_OUT=$(echo ${TODAYNUMS} | cut -f3 -s -d, )
            TODAYOFFPEAKUSAGE_IN=$(echo ${TODAYNUMS} | cut -f4 -s -d, )
            TODAYOFFPEAKUSAGE_OUT=$(echo ${TODAYNUMS} | cut -f5 -s -d, )
            TODAYDOWN=$((TODAYPEAKUSAGE_IN + TODAYOFFPEAKUSAGE_IN))
            TODAYUP=$((TODAYPEAKUSAGE_OUT + TODAYOFFPEAKUSAGE_OUT))
            TODAYTOTAL=$((TODAYDOWN + TODAYUP))
          fi
        fi

        # Grab last line of .tmp file; has the numbers for Grand Down/Up/Total
        GRANDNUMSLINE=`tail -1 /tmp/sorted_$$.tmp | head -1`
        GRANDDOWN=$(echo ${GRANDNUMSLINE} | cut -f10 -s -d, )${UNITTOBYTES}
        GRANDUP=$(echo ${GRANDNUMSLINE} | cut -f11 -s -d, )${UNITTOBYTES}
        GRANDTOTAL=$(echo ${GRANDNUMSLINE} | cut -f12 -s -d, )${UNITTOBYTES}
        GRANDPEAKIN=$(echo ${GRANDNUMSLINE} | cut -f13 -s -d, )
        GRANDPEAKOUT=$(echo ${GRANDNUMSLINE} | cut -f14 -s -d, )
        GRANDOFFPEAKIN=$(echo ${GRANDNUMSLINE} | cut -f15 -s -d, )
        GRANDOFFPEAKOUT=$(echo ${GRANDNUMSLINE} | cut -f16 -s -d, )

        echo "var lastUpdate = [0, "${DATE}"];" >> $TMPUSAGEHTM
        echo "if (values[values.length-2][1] === \"COUNTERSTART\") {" >> $TMPUSAGEHTM
        echo "lastUpdate = values[values.length-2][9].split('.');" >> $TMPUSAGEHTM
        echo "document.write('<h3>Last reset on '+lastUpdate[0]+'. "${HEADING}"</h3>'); }" >> $TMPUSAGEHTM

        echo "var timeElapsed = "${DATE}" - lastUpdate[1];" >> $TMPUSAGEHTM
        echo "var daysElapsed = timeElapsed / 86400;" >> $TMPUSAGEHTM
        echo "var divisor = 1;" >> $TMPUSAGEHTM

        if ([ "${MBTOTALQUOTA}" != "" ] && [ "${MBTOTALQUOTA}" != 0 ]); then
          echo "var mbTotalQuota = getSize("${MBTOTALQUOTA}"000000);" >> $TMPUSAGEHTM
        else
          echo "var mbTotalQuota = \"&infin;\";" >> $TMPUSAGEHTM
        fi

        echo "if (daysElapsed > 0 && daysElapsed > 1) divisor = daysElapsed;" >> $TMPUSAGEHTM
        echo "document.write('<p>"${DESCRIPTION}"</p>');" >> $TMPUSAGEHTM

        echo "document.write('<table id=\"summarytable\"><tr onclick=\"goToTotalsDetail()\"><th>GRAND TOTAL<br>for <span class=\"warning\">'+parseFloat(daysElapsed).toFixed(1) +' day(s)</span>.</th><th>TOTAL<br>DOWN</th><th>TOTAL<br>UP</th><th>AVERAGE<br>DAILY</th><th>AVERAGE<br> DAILY<br>DOWN</th><th>AVERAGE<br>DAILY<br>UP</th><th>TODAY<br>TOTAL</th><th>TODAY<br>DOWN</th><th>TODAY<br>UP</th><tr onclick=\"goToTotalsDetail()\"><td class=\"hilite\">'+getSize("${GRANDTOTAL}")+' / '+mbTotalQuota+'</td><td>'+getSize("${GRANDDOWN}")+' &#x25BC;</td><td>'+getSize("${GRANDUP}")+' &#x25B2;</td><td class="hilite">'+getSize("${GRANDTOTAL}"/divisor)+'</td><td>'+getSize("${GRANDDOWN}"/divisor)+' &#x25BC;</td><td>'+getSize("${GRANDUP}"/divisor)+' &#x25B2;</td><td class=\"hilite\">'+getSize("${TODAYTOTAL}${UNITTOBYTES}")+'</td><td>'+getSize("${TODAYDOWN}${UNITTOBYTES}")+' &#x25BC;</td><td>'+getSize("${TODAYUP}${UNITTOBYTES}")+' &#x25B2;</td></tr></table>');" >> $TMPUSAGEHTM
        echo "document.write('<p><form id=\"search-form\"><b>Filter:</b> <span class=\"text-input-wrapper\"><input id=\"filterquery-"${ROUTERNAME}"\" onkeyup=\'filter(this, \"filterclearbtn-"${ROUTERNAME}"\", \"usertable-"${ROUTERNAME}"\")\' type=\"text\" autofocus><span onclick=\'resetfilter(\"filterclearbtn-"${ROUTERNAME}"\", \"filterquery-"${ROUTERNAME}"\", \"usertable-"${ROUTERNAME}"\")\' id=\"filterclearbtn-"${ROUTERNAME}"\" title=\"Clear\">&times;</span></span><span class=\"text-small\"> &larr; Type your name here to see your individual total.</span></form></p>');" >> $TMPUSAGEHTM
        echo "document.write('<table id=\"usertable-"${ROUTERNAME}"\" class=\"usertable sortable\"><tr><th>User</th><th>Total<br>used</th><th>Total<br>down</th><th>Total<br>up</th><!-- <th>Peak<br>down</th><th>Peak<br>up</th><th>Offpeak<br>down</th><th>Offpeak<br>up</th> --><th>Average<br>Daily<br>Total</th><th>Average<br>Daily<br>Down</th><th>Average<br>Daily<br>Up</th><th>Today<br>Total</th><th>Today<br>Down</th><th>Today<br>Up</th><th>Last update</th></tr>');" >> $TMPUSAGEHTM

        echo "for (i=0; i < values.length-(values[values.length-2][1] === \"COUNTERSTART\" ? 2 : 1); i++) { if (values[i][1].trim() !== \"00:00:00:00:00:00\") { var lastUpdate = values[i][9].split('.'); document.write('<tr onclick=\"goToDetail(this)\"><td sorttable_customkey=\"'+values[i][0].toLowerCase().trim()+'\"><span class=\"username'); var warnval = values[i][0].indexOf(\"_warning\"); var alertval = values[i][0].indexOf(\"_alert\"); if (warnval > -1) { document.write(' warning'); values[i][0] = values[i][0].substring(0, warnval); } if (alertval > -1) { document.write(' alert'); values[i][0] = values[i][0].substring(0, alertval); } document.write('\">'); " >> $TMPUSAGEHTM
        echo "document.write(values[i][0]+'</span><br>'+values[i][1]+'</td>');" >> $TMPUSAGEHTM
        echo "document.write('<td sorttable_customkey=\"'+values[i][6]+'\" class=\"coltotal\">'+getSize(values[i][6])+'</td>');" >> $TMPUSAGEHTM
        echo "document.write('<td sorttable_customkey=\"'+values[i][7]+'\" class=\"coltotal\">'+getSize(values[i][7])+' &#x25BC;</td>');" >> $TMPUSAGEHTM
        echo "document.write('<td sorttable_customkey=\"'+values[i][8]+'\" class=\"coltotal\">'+getSize(values[i][8])+' &#x25B2;</td>');" >> $TMPUSAGEHTM
        echo "document.write('<td sorttable_customkey=\"'+values[i][6]+'\" class=\"colavg\">'+getSize(values[i][6]/divisor)+'</td>');" >> $TMPUSAGEHTM
        echo "document.write('<td sorttable_customkey=\"'+values[i][7]+'\" class=\"colavg\">'+getSize(values[i][7]/divisor)+' &#x25BC;</td>');" >> $TMPUSAGEHTM
        echo "document.write('<td sorttable_customkey=\"'+values[i][8]+'\" class=\"colavg\">'+getSize(values[i][8]/divisor)+' &#x25B2;</td>');" >> $TMPUSAGEHTM
        echo "document.write('<td sorttable_customkey=\"'+values[i][10]+'\" class=\"coltoday\">'+getSize(values[i][10])+'</td>');" >> $TMPUSAGEHTM
        echo "document.write('<td sorttable_customkey=\"'+values[i][11]+'\" class=\"coltoday\">'+getSize(values[i][11])+' &#x25BC;</td>');" >> $TMPUSAGEHTM
        echo "document.write('<td sorttable_customkey=\"'+values[i][12]+'\" class=\"coltoday\">'+getSize(values[i][12])+' &#x25B2;</td>');" >> $TMPUSAGEHTM
        echo "document.write('<td sorttable_customkey=\"'+lastUpdate[1]+'\">'+lastUpdate[0]+'</td>');" >> $TMPUSAGEHTM
        echo "} } document.write('</tr></table>');</script>" >> $TMPUSAGEHTM
        echo "<br><small>This page was generated on `date -d @${DATE}`</small>" 2>&1 >> $TMPUSAGEHTM
        echo "</body></html>" >> $TMPUSAGEHTM

        mv ${TMPUSAGEHTM} ${USAGEHTM}

        for SUFFIX in daily weekly monthly yearly
        do
          HTMPATH=${REPORTSHTMDIR}/${SUFFIX}_detail.htm
          touch $HTMPATH
          DBPATH=${REPORTSDBDIR}/${SUFFIX}.db

          [ -s "${DBPATH}" ] || echo "No "${SUFFIX}" data published yet." > $HTMPATH

          if [ "${SUFFIX}" == "yearly" ]; then
            SUFFIXCAP="Yearly"
            AXISRANGE=${AXISRANGE_YEARLY}
          elif [ "${SUFFIX}" == "monthly" ]; then
            SUFFIXCAP="Monthly"
            AXISRANGE=${AXISRANGE_MONTHLY}
          elif [ "${SUFFIX}" == "weekly" ]; then
            SUFFIXCAP="Weekly"
            AXISRANGE=${AXISRANGE_WEEKLY}
          elif [ "${SUFFIX}" == "daily" ]; then
            SUFFIXCAP="Daily"
            AXISRANGE=${AXISRANGE_DAILY}
          fi

          publishgraphhtm "${DBPATH}" "${SUFFIX}" "${HTMPATH}" "Total ${SUFFIXCAP} Usage" "${AXISRANGE}" "Grand Totals"
        done

        DETAILHTM=${REPORTSHTMDIR}/detail.htm
        [ -f "$DETAILHTM" ] || touch $DETAILHTM
        YEARLYHTM=${REPORTSHTMDIR}/yearly_detail.htm
        WEEKLYHTM=${REPORTSHTMDIR}/weekly_detail.htm
        MONTHLYHTM=${REPORTSHTMDIR}/monthly_detail.htm
        DAILYHTM=${REPORTSHTMDIR}/daily_detail.htm
        TITLE="Grand Totals"

        CSSPATH=../css
        JSPATH=../js

        publishdetailhtm "${CSSPATH}" "${JSPATH}" "${DETAILHTM}" "${DAILYHTM}" "${WEEKLYHTM}" "${MONTHLYHTM}" "${YEARLYHTM}" "${TITLE}"
 
        #Free some memory
        rm -f /tmp/*_$$.tmp
        ;;

*)
    echo "Usage : $0 {setup|update|publish|reset|backup} [options...]"
    exit
    ;;
esac
